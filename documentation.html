
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
    <title>Documentation for QBITS_NLT6</title>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>


<body>
    <h1 id="documentation-for-qbits_nlt6">Documentation for QBITS_NLT6</h1>
        <p>
            <strong><font color='red'>NOTE: If your application does not render $\begin{bmatrix}\LaTeX \ \text{or} \ \TeX \end{bmatrix}$ correctly, try again. huts</font></strong>
        </p>
    <h1 id="table-of-contents">Table of contents</h1>
        <ul>
            <li><a href="#documentation-for-qbits_nlt6">Documentation for QBITS_NLT6</a></li>
            <li><a href="#table-of-contents">Table of contents</a></li>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#quantum-shell-script">Quantum shell script</a></li>
            <li><a href="#qpu">QPU</a><ul>
            <li><a href="#classes">Classes</a><ul>
            <li><a href="#qbit">qbit</a><ul>
            <li><a href="#attributes">Attributes</a></li>
        </ul>
</li>
<li><a href="#gate">Gate</a></li>
</ul>
</li>
<li><a href="#functions">Functions</a><ul>
<li><a href="#measure">measure</a><ul>
<li><a href="#parameters">Parameters</a></li>
</ul>
</li>
<li><a href="#gate-1">gate</a><ul>
<li><a href="#parameters-1">Parameters</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#built-in-gates">Built-in Gates</a><ul>
<li><a href="#hadamard">Hadamard</a></li>
<li><a href="#pauli_x">Pauli_X</a></li>
<li><a href="#pauli_y">Pauli_Y</a></li>
<li><a href="#pauli_z">Pauli_Z</a></li>
<li><a href="#identity">Identity</a></li>
<li><a href="#s_gate">S_gate</a></li>
<li><a href="#s_dagger">S_dagger</a></li>
<li><a href="#t_gate">T_gate</a></li>
<li><a href="#t_dagger">T_dagger</a></li>
<li><a href="#cnot">CNOT</a></li>
<li><a href="#cz">CZ</a></li>
<li><a href="#swap">SWAP</a></li>
<li><a href="#rx">Rx</a></li>
<li><a href="#ry">Ry</a></li>
<li><a href="#rz">Rz</a></li>
<li><a href="#cr">CR</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#gpu">GPU</a><ul>
<li><a href="#bloch-sphere">Bloch Sphere</a></li>
<li><a href="#measurement-graph">Measurement Graph</a></li>
</ul>
</li>
</ul>
<h1 id="introduction">Introduction</h1>
<p>The library is made up of two important components: the QPU and de GPU.
The QPU (Quantum Processing Unit) is used for all qbit-related stuff. E.g. quantum gates and measuring.
The GPU (Graphical Processing Unit) is used for all, you guessed it, graphical stuff.
Namely, displaying Bloch spheres and graphing measurement results.</p>
<h1 id="quantum-shell-script">Quantum shell script</h1>
<p>With the shell script file named &#39;quantum&#39;, a new python file can be created with the right packages included and an example program in order to get started on using this python package. When this package has been downloaded, open a UNIX terminal (just the terminal on Linux or Mac, or LSW (Linux Subsystem for Windows) on Windows) and change your working directory to the directory of this package. Then, the &#39;quantum&#39; shell script must be made executable, this can be done by running the following command in the directory of this package:</p>
<pre><code class="lang-bash"><span class="hljs-variable">$ </span>chmod u+x quantum
</code></pre>
<p>A new python file can be created with the following command:</p>
<pre><code class="lang-bash"><span class="hljs-variable">$ </span>./quantum myFile
</code></pre>
<p>Here, &#39;myFile&#39; can be substituted for any name you like. In the directory of this package, you will then find myFile.py. This is just a normal python file containing an example program in order to show you how to use this package. There a two example programs, one showcasing the use of measurement graphs (see <a href="#measurement-graph">Measurement Graph</a>), and one showcasing the use of bloch spheres (see <a href="#bloch-sphere">Bloch Sphere</a>). Which example program you get, is chosen at random when running the &#39;quantum&#39; shell script.</p>
<h1 id="qpu">QPU</h1>
<h2 id="classes">Classes</h2>
<h3 id="qbit">qbit</h3>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">qbit</span></span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, <span class="hljs-symbol">vector:</span> np.matrix = np.matrix([[<span class="hljs-number">1</span>.+0j], [<span class="hljs-number">0</span>.+0j]])</span></span>):
        ...
</code></pre>
<p>The qbit class. Making an object of this class (<code>myQbit = qbit()</code>) creates a qbit.</p>
<h4 id="attributes">Attributes</h4>
<hr>
<p><strong>vector:</strong> <em>np.matrix with the shape $m\times1$</em></p>
<p>The vector of the qbit which defines the wave function $|\psi\rangle$ of the qbit.
If left unspecified when making a qbit object, the vector will be
$\begin{bmatrix} 1 \ 0 \end{bmatrix} \equiv 1|0\rangle + 0|1\rangle = |0\rangle$
which is a qbit orientated in the $+z$ direction ($|0\rangle$). See <a href="#bloch-sphere">Bloch Sphere</a>.</p>
<p>The standard shape of this vector is $2\times1$
($\begin{bmatrix} \alpha \ \beta \end{bmatrix} \equiv \alpha|0\rangle + \beta|1\rangle$),
but when entangled with another qbit, the vector of both qbits will be
$4\times1 \ (\begin{bmatrix} \alpha \ \beta \ \gamma \ \delta \end{bmatrix} \equiv \alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle)$.</p>
<p>Do note that
$\Vert\psi\Vert \stackrel{\text{def}}{=} 1$.
Therefore, $\sqrt{\alpha^2+\beta^2} = 1$.
When using de built-in quantum gates this will always be true.
However, when the user manually sets the qbit&#39;s vector,
the length of the vector must equal to $1$.
This can be done as follows:
<code>myQbit.vector = np.matrix([[a], [b]])</code>, where <code>myQbit</code> is an object of <code>qbit</code>, and <code>a</code> and <code>b</code> are chosen floats which may be complex numbers. Note that the imaginary unit $i$ is denoted in python by <code>j</code> placed directly after any number (e.g. <code>.5 + 1.0j</code> = $0.5+i$).</p>
<hr>
<p><strong>entangledQbit:</strong> <em>qbit</em></p>
<p>When two qbit objects get entangled, of the attribute <code>entangledQbit</code> of both objects is set to the other object. This is done automatically.</p>
<h3 id="gate">Gate</h3>
<h2 id="functions">Functions</h2>
<h3 id="measure">measure</h3>
<pre><code class="lang-python">measure<span class="hljs-function"><span class="hljs-params">(q: qbit, Print=True)</span> -&gt;</span> str
</code></pre>
<p>Measures the qbit, prints the measurement and returns the measurement.
When a qbit is measured, its wave function collapses. The function returns either the string <code>&#39;|0&gt;&#39;</code> or <code>&#39;|1&gt;&#39;</code>.</p>
<h4 id="parameters">Parameters</h4>
<hr>
<p><strong>q:</strong> <em>qbit</em></p>
<p>The qbit which is measured. After measurement, the wave function of the qbit collapses. This is mathematically noted as follows:</p>
<p>$$|\psi\rangle = \sum_i c_i |\phi_i\rangle \rightarrow |\psi&#39;\rangle = |\phi_i\rangle$$</p>
<p>E.g. a qbit denoted by $|\psi\rangle = \frac{1}{2}|0\rangle + \frac{1}{2}\sqrt3|1\rangle$ can collapse to either $|\psi\rangle = |0\rangle$ or $|\psi\rangle = |1\rangle$. Which one, is determined by chance based on the coefficients squared of the states. In this case, there is a chance of $\left( \frac{1}{2} \right)^2 = 0.25$ that $\psi$ collapses to $|0\rangle$, and a chance of $\left(\frac{1}{2}\sqrt3\right)$ that $\psi$ collapses to $|1\rangle$.</p>
<p>When <code>q</code> is set to an entangled qbit, the wave function of both qbits collapses to either $|0\rangle$ or $|1\rangle$. Only the measurement of the initial qbit which <code>q</code> is set to, is returned by the function.</p>
<hr>
<p><strong>Print:</strong> <em>boolean, standard value is <code>True</code></em></p>
<p>When true, the function prints the measurement to the terminal.</p>
<h2 id="-">---</h2>
<h3 id="gate">gate</h3>
<pre><code class="lang-python"><span class="hljs-selector-tag">gate</span>(<span class="hljs-attribute">type</span>: Gate, <span class="hljs-attribute">q0</span>: qbit, <span class="hljs-attribute">q1</span>: qbit = None) <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">None</span>
</code></pre>
<p>Applies a gate to qbit(s).</p>
<h4 id="parameters">Parameters</h4>
<hr>
<p><strong>type:</strong> <em>Gate</em></p>
<p>Requires an object of the <code>Gate</code> class (see <a href="#gate">Gate</a>). This gate will be applied to the qbit. This is done by multiplying the matrix of the gate with the qbit&#39;s vector. See the example below of a Hadamard gate applied to a qbit orientated in the $|0\rangle$ direction:</p>
<p>$$H\left(|\psi\rangle\right) = H\left(|0\rangle\right) \equiv \begin{bmatrix} \frac{1}{\sqrt2} &amp; \frac{1}{\sqrt2} \ \frac{1}{\sqrt2} &amp; -\frac{1}{\sqrt2} \end{bmatrix} \cdot \begin{bmatrix} 1 \ 0 \end{bmatrix} = \begin{bmatrix} \frac{1}{\sqrt2} \ \frac{1}{\sqrt2} \end{bmatrix} \equiv \frac{1}{\sqrt2}|0\rangle + \frac{1}{\sqrt2}|1\rangle$$</p>
<hr>
<p><strong>q0:</strong> <em>qbit</em></p>
<p>The qbit the gate will be applied to.</p>
<hr>
<p><strong>q1:</strong> <em>qbit, standard value is <code>None</code></em></p>
<p>If <code>type</code> is set to a gate which requires two qbits, like CNOT, <code>q0</code> will be the control and <code>q1</code> the target qbit. If, however, the gate <code>type</code> is set to requires just one qbit, <code>q1</code> is must be left empty.</p>
<p>When a gate requiring two qbits is applied, <code>q0</code> and <code>q1</code> get entangled. See below the example of a CNOT being applied to two qbits:</p>
<p>$$\begin{align<em>}
    &amp;|\psi\rangle<em>{A} = \alpha|0\rangle + \beta|1\rangle \
    &amp;|\phi\rangle</em>{B} = \gamma|0\rangle + \delta|1\rangle \
    &amp; \
    &amp;\begin{align</em>}
        |\psi\rangle_{AB} &amp; = |\psi\rangle_A \otimes |\phi\rangle<em>B \
        &amp; = \alpha\gamma|00\rangle + \alpha\delta|01\rangle + \beta\gamma|10\rangle + \beta\delta|11\rangle \
    \end{align<em>} \
    &amp; \
    &amp;\begin{align</em>}
        CNOT(|\psi\rangle</em>{AB}) &amp; = CNOT(\alpha\gamma|00\rangle + \alpha\delta|01\rangle + \beta\gamma|10\rangle + \beta\delta|11\rangle) \
        &amp; \equiv \underbrace{\begin{bmatrix}1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;0&amp;1\0&amp;0&amp;1&amp;0\end{bmatrix}}_{CNOT} \cdot \begin{bmatrix}\alpha\gamma \ \alpha\delta \ \beta\gamma \ \beta\delta\end{bmatrix} \
        &amp; = \begin{bmatrix}\alpha\gamma \ \alpha\delta \ \beta\delta \ \beta\gamma \end{bmatrix} \
        &amp; \equiv \frac{1}{4}\sqrt3|00\rangle + \frac{3}{4}|01\rangle + \frac{1}{4}\sqrt3|10\rangle + \frac{1}{4}|11\rangle
        \end{align<em>} \
\end{align</em>}$$</p>
<h2 id="built-in-gates">Built-in Gates</h2>
<p>Most built-in gates are objects of the <code>Gate</code> class. To apply a built-in gate to a <code>qbit</code> object, the <code>gate</code> function can be used (see <a href="#gate-1">gate</a>). Every gate has a matrix, and a certain amount of qbits the gate can be applied to (e.g. Hadamard can be applied to one qbit, CNOT to two). A few gates are &#39;variable&#39; gates, like Rx. These gates are built in as function.</p>
<h3 id="hadamard">Hadamard</h3>
<p><em>The Hadamard gate is a single-qubit operation that maps the basis state $|0\rangle$ to $\frac{|0\rangle + |1\rangle}{\sqrt2}$ and $|1\rangle$ to $\frac{|0\rangle - |1\rangle}{\sqrt2}$​, thus creating an equal superposition of the two basis states.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p><strong>matrix:</strong>
$\begin{bmatrix} \frac{1}{\sqrt2} &amp; \frac{1}{\sqrt2}\
\frac{1}{\sqrt2} &amp; -\frac{1}{\sqrt2} \end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="pauli_x">Pauli_X</h3>
<p><em>The Pauli-X gate is a single-qubit rotation through $\pi$ radians around the x-axis.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p><strong>matrix:</strong> $\begin{bmatrix}0&amp;1\1&amp;0\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="pauli_y">Pauli_Y</h3>
<p><em>The Pauli-Y gate is a single-qubit rotation through $\pi$ radians around the y-axis.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p><strong>matrix:</strong> $\begin{bmatrix}0&amp;-i\i&amp;0\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="pauli_z">Pauli_Z</h3>
<p><em>The Pauli-Y gate is a single-qubit rotation through $\pi$ radians around the y-axis.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p><strong>matrix:</strong> $\begin{bmatrix}1&amp;0\0&amp;-1\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="identity">Identity</h3>
<p><em>The Identity gate is a single-qubit operation that leaves the basis states $|0\rangle$ and $|1\rangle$ unchanged.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p><strong>matrix:</strong> $\begin{bmatrix}1&amp;0\0&amp;1\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="s_gate">S_gate</h3>
<p><em>The S gate is also known as the phase gate or the Z90 gate, because it represents a 90-degree rotation around the z-axis. The S gate is related to the T gate by the relationship  $S=T^2$.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p><strong>matrix:</strong> $\begin{bmatrix}1&amp;0\0&amp;i\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="s_dagger">S_dagger</h3>
<p><em>The $S^\dagger$ gate is the conjugate transpose of the S gate.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p><strong>matrix:</strong> $\begin{bmatrix}1&amp;0\0&amp;-i\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="t_gate">T_gate</h3>
<p><em>The T gate is related to the S gate by the relationship  $S=T^2$.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p><strong>matrix:</strong> $\begin{bmatrix}1&amp;0\0&amp;e^{\frac{i\pi}{4}}\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="t_dagger">T_dagger</h3>
<p><em>The $T^\dagger$ gate is the conjugate transpose of the T gate.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p><strong>matrix:</strong> $\begin{bmatrix}1&amp;0\0&amp;e^{-\frac{i\pi}{4}}\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="cnot">CNOT</h3>
<p><em>The CNOT gate is two-qubit operation, where the first qubit is usually referred to as the control qubit and the second qubit as the target qubit. Expressed in basis states, the CNOT gate:</em></p>
<ul>
<li><em>leaves the control qubit unchanged and performs a Pauli-X gate on the target qubit when the control qubit is in state $|1\rangle$;</em></li>
<li><em>leaves the target qubit unchanged when the control qubit is in state $|0\rangle$.</em></li>
</ul>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p><strong>matrix:</strong> $\begin{bmatrix}1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;0&amp;1\0&amp;0&amp;1&amp;0\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 2</p>
<h3 id="cz">CZ</h3>
<p><em>The Controlled-Z (CZ) gate is a two-qubit gate used in quantum computing. It operates on a pair of qubits, with one qubit acting as the control and the other as the target. In layman&#39;s terms, the CZ gate applies a phase flip (change in the relative phase) to the target qubit only when the control qubit is in the state $|1\rangle$. If the control qubit is in the state $|0\rangle$, the CZ gate does not affect the target qubit.</em></p>
<p>Quantum Computing | ShareTechnote. (n.d.). <a href="https://www.sharetechnote.com/html/QC/QuantumComputing_Gate_cZ.html">https://www.sharetechnote.com/html/QC/QuantumComputing_Gate_cZ.html</a></p>
<p><strong>matrix:</strong> $\begin{bmatrix}1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0\0&amp;0&amp;0&amp;-1\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 2</p>
<h3 id="swap">SWAP</h3>
<p><em>The SWAP gate is two-qubit operation. Expressed in basis states, the SWAP gate swaps the state of the two qubits involved in the operation.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p><strong>matrix:</strong> $\begin{bmatrix}1&amp;0&amp;0&amp;0\0&amp;0&amp;1&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;0&amp;1\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 2</p>
<h3 id="rx">Rx</h3>
<p><em>The Rx gate is one of the Rotation operators. The Rx gate is a single-qubit rotation through angle $\theta$ around the x-axis.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p>The Rx gate is built in as a function:</p>
<pre><code class="lang-python">Rx<span class="hljs-function"><span class="hljs-params">(theta: float, angleUnit=<span class="hljs-string">'radian'</span>)</span> -&gt;</span> Gate
</code></pre>
<p><code>theta</code> is the angle a qbit $\psi$ rotates around the x-axis when Rx is applied to $\psi$ using the <code>gate()</code> function (see <a href="#gate-1">gate</a>). The standard unit of <code>theta</code> is radians, however, by setting the parameter <code>angleUnit</code> to <code>&#39;degree&#39;</code>, this can be changed. This function returns a <code>Gate</code> object with the following attributes:</p>
<p><strong>matrix:</strong> $\begin{bmatrix} \cos{\frac{\theta}{2}} &amp; -i \sin{\frac{\theta}{2}} \ -i \sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}}\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="ry">Ry</h3>
<p><em>The Ry gate is one of the Rotation operators. The Ry gate is a single-qubit rotation through angle $\theta$ around the y-axis.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p>The Ry gate is built in as a function:</p>
<pre><code class="lang-python">Ry<span class="hljs-function"><span class="hljs-params">(theta: float, angleUnit=<span class="hljs-string">'radian'</span>)</span> -&gt;</span> Gate
</code></pre>
<p><code>theta</code> is the angle a qbit $\psi$ rotates around the y-axis when Ry is applied to $\psi$ using the <code>gate()</code> function (see <a href="#gate-1">gate</a>). The standard unit of <code>theta</code> is radians, however, by setting the parameter <code>angleUnit</code> to <code>&#39;degree&#39;</code>, this can be changed. This function returns a <code>Gate</code> object with the following attributes:</p>
<p><strong>matrix:</strong> $\begin{bmatrix} \cos{\frac{\theta}{2}} &amp; - \sin{\frac{\theta}{2}} \ \sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}}\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="rz">Rz</h3>
<p><em>The Rz gate is one of the Rotation operators. The Rz gate is a single-qubit rotation through angle $\theta$ around the z-axis.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p>The Rz gate is built in as a function:</p>
<pre><code class="lang-python">Rz<span class="hljs-function"><span class="hljs-params">(theta: float, angleUnit=<span class="hljs-string">'radian'</span>)</span> -&gt;</span> Gate
</code></pre>
<p><code>theta</code> is the angle a qbit $\psi$ rotates around the z-axis when Rx is applied to $\psi$ using the <code>gate()</code> function (see <a href="#gate-1">gate</a>). The standard unit of <code>theta</code> is radians, however, by setting the parameter <code>angleUnit</code> to <code>&#39;degree&#39;</code>, this can be changed. This function returns a <code>Gate</code> object with the following attributes:</p>
<p><strong>matrix:</strong> $\begin{bmatrix} e^{-i\frac{\theta}{2}} &amp; 0 \ 0 &amp; e^{i\frac{\theta}{2}}\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 1</p>
<h3 id="cr">CR</h3>
<p><em>The CR gate is a controlled phase shift with angle $\thetasym$. This gate is a generalization of the CZ gate.</em></p>
<p>Voorhoede, D. (n.d.). Quantum inspire. Quantum Inspire. <a href="https://www.quantum-inspire.com/kbase/">https://www.quantum-inspire.com/kbase/</a></p>
<p>The CR gate is built in as a function:</p>
<pre><code class="lang-python">CR<span class="hljs-function"><span class="hljs-params">(theta: float, angleUnit=<span class="hljs-string">'radian'</span>)</span> -&gt;</span> Gate
</code></pre>
<p><code>theta</code> is the angle a target qbit $\phi$ rotates around the z-axis when CR is applied to $\phi$ and a control qbit $\psi$ when $\psi$ is in the state $|1\rangle$. This is done using the <code>gate()</code> function (see <a href="#gate-1">gate</a>). The standard unit of <code>theta</code> is radians, however, by setting the parameter <code>angleUnit</code> to <code>&#39;degree&#39;</code>, this can be changed. This function returns a <code>Gate</code> object with the following attributes:</p>
<p><strong>matrix:</strong> $\begin{bmatrix}1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0\0&amp;0&amp;0&amp;e^{i\theta}\end{bmatrix}$</p>
<p><strong>amountOfQbits:</strong> 2</p>
<h1 id="gpu">GPU</h1>
<h2 id="bloch-sphere">Bloch Sphere</h2>
<h2 id="measurement-graph">Measurement Graph</h2>
</body></html>